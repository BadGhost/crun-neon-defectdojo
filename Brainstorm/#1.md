Of course. Here is a comprehensive, step-by-step guide to deploying django-defectdojo to Google Cloud Run using Terraform, with a serverless Neon database.

### **Prerequisites**

Before you begin, ensure you have the following installed and configured:

1. **Google Cloud SDK (gcloud CLI):** [Installation Guide](https://cloud.google.com/sdk/docs/install). Make sure to authenticate by running gcloud auth login and gcloud auth application-default login.  
2. **Terraform:** [Installation Guide](https://learn.hashicorp.com/tutorials/terraform/install-cli).  
3. **Docker:** [Installation Guide](https://docs.docker.com/get-docker/).  
4. **A Neon Account:** Sign up for free at [Neon](https://neon.tech).  
5. **A Google Cloud Project:** Create a new project in the [GCP Console](https://console.cloud.google.com/).  
6. **Cloned django-defectdojo Repository:** You should have the source code on your local machine.  
   Bash  
   git clone https://github.com/DefectDojo/django-defectdojo.git  
   cd django-defectdojo

---

### **Step 1: Set Up Your Neon Database**

First, we will create the PostgreSQL database on Neon.

1. **Create a Neon Project:** Log in to the [Neon Console](https://console.neon.tech/) and create a new project.  
2. **Get the Connection String:** On your project dashboard, find the **Connection Details** widget. Copy the **Connection String** that looks like this:  
   postgres://\<user\>:\<password\>@\<endpoint\_hostname\>.neon.tech/neondb?sslmode=require

   Keep this connection string handy. We will store it securely in the next step.

---

### **Step 2: Configure Your Google Cloud Project**

Now, we'll set up your GCP project by enabling the necessary APIs and storing secrets.

1. **Set Project Configuration:** In your terminal, run the following commands, replacing your-gcp-project-id with your actual project ID.  
   Bash  
   gcloud config set project your-gcp-project-id

2. **Enable GCP APIs:** This command enables all the services we'll need.  
   Bash  
   gcloud services enable \\  
     run.googleapis.com \\  
     iam.googleapis.com \\  
     secretmanager.googleapis.com \\  
     redis.googleapis.com \\  
     servicenetworking.googleapis.com \\  
     cloudbuild.googleapis.com \\  
     artifactregistry.googleapis.com

3. **Store Secrets in Secret Manager:** We will store all sensitive values, including the Neon database URL and Django secret key, in Google Secret Manager.  
   * **Neon Database URL:**  
     Bash  
     \# Replace the placeholder with your actual Neon connection string  
     printf "postgres://user:password@endpoint.neon.tech/neondb?sslmode=require" | \\  
     gcloud secrets versions add neon-db-url \--secret="neon-db-url" \--data-file=-

   * **Django Secret Key:** Generate a random key and store it.  
     Bash  
     \# You can use any method to generate a strong random string  
     openssl rand \-base64 48 | \\  
     gcloud secrets versions add django-secret-key \--secret="django-secret-key" \--data-file=-

---

### **Step 3: Build and Push Docker Images**

DefectDojo requires several services. We need to build a Docker image for each and push them to Google's Artifact Registry.

1. **Create a Docker Repository:**  
   Bash  
   gcloud artifacts repositories create defectdojo-repo \\  
     \--repository-format=docker \\  
     \--location=us-central1 \\  
     \--description="Docker repository for DefectDojo"

2. **Configure Docker Authentication:**  
   Bash  
   gcloud auth configure-docker us-central1-docker.pkg.dev

3. **Build and Push the Images:** Run these commands from the root of the django-defectdojo repository. This process can take some time.  
   * **Base Image Path:**  
     Bash  
     export IMAGE\_PATH="us-central1-docker.pkg.dev/your-gcp-project-id/defectdojo-repo"

   * **Build & Push uwsgi:**  
     Bash  
     docker build \-t $IMAGE\_PATH/uwsgi:latest \-f docker/Dockerfile .  
     docker push $IMAGE\_PATH/uwsgi:latest

   * **Build & Push celeryworker:**  
     Bash  
     docker build \-t $IMAGE\_PATH/celeryworker:latest \-f docker/Dockerfile.celery-worker .  
     docker push $IMAGE\_PATH/celeryworker:latest

   * **Build & Push celerybeat:**  
     Bash  
     docker build \-t $IMAGE\_PATH/celerybeat:latest \-f docker/Dockerfile.celery-beat .  
     docker push $IMAGE\_PATH/celerybeat:latest

   * **Build & Push initializer:**  
     Bash  
     docker build \-t $IMAGE\_PATH/initializer:latest \-f docker/Dockerfile.initializer .  
     docker push $IMAGE\_PATH/initializer:latest

---

### **Step 4: Write the Terraform Code**

Create a new directory for your Terraform files and add the following files inside it.

#### **provider.tf**

Terraform

terraform {  
  required\_providers {  
    google \= {  
      source  \= "hashicorp/google"  
      version \= "\~\> 4.25"  
    }  
  }  
}

provider "google" {  
  project \= var.gcp\_project\_id  
  region  \= var.gcp\_region  
}

provider "google-beta" {  
  project \= var.gcp\_project\_id  
  region  \= var.gcp\_region  
}

#### **variables.tf**

Terraform

variable "gcp\_project\_id" {  
  description \= "The GCP project ID to deploy to."  
  type        \= string  
}

variable "gcp\_region" {  
  description \= "The GCP region to deploy resources in."  
  type        \= string  
  default     \= "us-central1"  
}

variable "image\_path" {  
  description \= "The path to the Docker images in Artifact Registry."  
  type        \= string  
  \# Example: "us-central1-docker.pkg.dev/your-project-id/defectdojo-repo"  
}

#### **network.tf**

Terraform

resource "google\_compute\_network" "vpc\_network" {  
  name                    \= "defectdojo-vpc"  
  auto\_create\_subnetworks \= false  
}

resource "google\_compute\_subnetwork" "default" {  
  name          \= "defectdojo-subnet"  
  ip\_cidr\_range \= "10.0.0.0/24"  
  network       \= google\_compute\_network.vpc\_network.id  
}

resource "google\_redis\_instance" "main" {  
  name               \= "defectdojo-redis"  
  tier               \= "BASIC"  
  memory\_size\_gb     \= 1  
  authorized\_network \= google\_compute\_network.vpc\_network.id  
  connect\_mode       \= "DIRECT\_PEERING"

  \# The network needs a private service connection to Redis  
  depends\_on \= \[google\_service\_networking\_connection.private\_vpc\_connection\]  
}

\# This is required for the Redis instance to peer with the VPC.  
resource "google\_service\_networking\_connection" "private\_vpc\_connection" {  
  network                 \= google\_compute\_network.vpc\_network.id  
  service                 \= "servicenetworking.googleapis.com"  
  reserved\_peering\_ranges \= \[google\_compute\_global\_address.private\_ip\_address.name\]  
}

resource "google\_compute\_global\_address" "private\_ip\_address" {  
  name          \= "redis-peering-range"  
  purpose       \= "VPC\_PEERING"  
  address\_type  \= "INTERNAL"  
  prefix\_length \= 16  
  network       \= google\_compute\_network.vpc\_network.id  
}

\# This connector allows Cloud Run to access the VPC  
resource "google\_vpc\_access\_connector" "main" {  
  name          \= "defectdojo-connector"  
  network       \= google\_compute\_network.vpc\_network.id  
  subnet {  
    name \= google\_compute\_subnetwork.default.name  
  }  
}

#### **main.tf**

Terraform

locals {  
  \# Define environment variables once to reuse across services  
  env\_vars \= \[  
    {  
      name  \= "DD\_CELERY\_BROKER\_URL"  
      value \= "redis://${google\_redis\_instance.main.host}:${google\_redis\_instance.main.port}/0"  
    },  
    {  
      name      \= "DD\_SECRET\_KEY"  
      value\_from \= {  
        secret\_key\_ref \= {  
          secret  \= "django-secret-key"  
          version \= "latest"  
        }  
      }  
    },  
    {  
      name      \= "DD\_DATABASE\_URL"  
      value\_from \= {  
        secret\_key\_ref \= {  
          secret  \= "neon-db-url"  
          version \= "latest"  
        }  
      }  
    },  
    \# Add other non-sensitive environment variables from the docker-compose here  
    { name \= "DD\_TIME\_ZONE", value \= "UTC" },  
    { name \= "DD\_CELERY\_BROKER\_USE\_SSL", value \= "False" }  
  \]  
}

\# \-- UWSGI Service (The main web application) \--  
resource "google\_cloud\_run\_v2\_service" "uwsgi" {  
  name     \= "uwsgi"  
  location \= var.gcp\_region  
  ingress  \= "INGRESS\_TRAFFIC\_ALL"

  template {  
    \# Allow public access  
    service\_account \= google\_service\_account.run\_identity.email  
      
    containers {  
      image \= "${var.image\_path}/uwsgi:latest"  
      ports { container\_port \= 8080 }  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value)  
      }  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value\_from)  
      }  
    }  
    vpc\_access {  
      connector \= google\_vpc\_access\_connector.main.id  
      egress    \= "ALL\_TRAFFIC"  
    }  
  }  
}

\# \-- Celery Worker Service \--  
resource "google\_cloud\_run\_v2\_service" "celeryworker" {  
  name     \= "celeryworker"  
  location \= var.gcp\_region  
  \# This service does not need to be publicly accessible  
  ingress  \= "INGRESS\_TRAFFIC\_INTERNAL\_ONLY"

  template {  
    service\_account \= google\_service\_account.run\_identity.email  
    containers {  
      image   \= "${var.image\_path}/celeryworker:latest"  
      command \= \["celery", "-A", "dojo", "worker", "-l", "info", "--concurrency", "4"\]  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value)  
      }  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value\_from)  
      }  
    }  
    vpc\_access {  
      connector \= google\_vpc\_access\_connector.main.id  
      egress    \= "ALL\_TRAFFIC"  
    }  
  }  
}

\# \-- Celery Beat Service \--  
resource "google\_cloud\_run\_v2\_service" "celerybeat" {  
  name     \= "celerybeat"  
  location \= var.gcp\_region  
  \# This service does not need to be publicly accessible  
  ingress  \= "INGRESS\_TRAFFIC\_INTERNAL\_ONLY"

  template {  
    service\_account \= google\_service\_account.run\_identity.email  
    containers {  
      image   \= "${var.image\_path}/celerybeat:latest"  
      command \= \["celery", "-A", "dojo", "beat", "-l", "info", "--scheduler", "django\_celery\_beat.schedulers:DatabaseScheduler"\]  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value)  
      }  
      env {  
        for var in local.env\_vars : var.name \=\> var if can(var.value\_from)  
      }  
    }  
    vpc\_access {  
      connector \= google\_vpc\_access\_connector.main.id  
      egress    \= "ALL\_TRAFFIC"  
    }  
  }  
}

\# \-- Initializer Job (for database setup) \--  
resource "google\_cloud\_run\_v2\_job" "initializer" {  
  provider \= google-beta  
  name     \= "initializer"  
  location \= var.gcp\_region

  template {  
    template {  
      service\_account \= google\_service\_account.run\_identity.email  
      containers {  
        image \= "${var.image\_path}/initializer:latest"  
        env {  
          for var in local.env\_vars : var.name \=\> var if can(var.value)  
        }  
        env {  
          for var in local.env\_vars : var.name \=\> var if can(var.value\_from)  
        }  
      }  
      vpc\_access {  
        connector \= google\_vpc\_access\_connector.main.id  
        egress    \= "ALL\_TRAFFIC"  
      }  
    }  
  }  
}

#### **iam.tf**

Terraform

\# Create a dedicated service account for the Cloud Run services  
resource "google\_service\_account" "run\_identity" {  
  account\_id   \= "defectdojo-run-sa"  
  display\_name \= "DefectDojo Cloud Run Service Account"  
}

\# Allow the service account to access secrets  
resource "google\_secret\_manager\_secret\_iam\_member" "neon\_db\_url\_accessor" {  
  secret\_id \= "neon-db-url"  
  role      \= "roles/secretmanager.secretAccessor"  
  member    \= "serviceAccount:${google\_service\_account.run\_identity.email}"  
}

resource "google\_secret\_manager\_secret\_iam\_member" "django\_key\_accessor" {  
  secret\_id \= "django-secret-key"  
  role      \= "roles/secretmanager.secretAccessor"  
  member    \= "serviceAccount:${google\_service\_account.run\_identity.email}"  
}

\# Allow public access to the main uwsgi service  
resource "google\_cloud\_run\_v2\_service\_iam\_member" "allow\_public\_uwsgi" {  
  name     \= google\_cloud\_run\_v2\_service.uwsgi.name  
  location \= google\_cloud\_run\_v2\_service.uwsgi.location  
  role     \= "roles/run.invoker"  
  member   \= "allUsers"  
}

---

### **Step 5: Deploy with Terraform**

Now, you're ready to deploy the infrastructure.

1. **Create a terraform.tfvars file:** Create a file named terraform.tfvars in the same directory and add your project-specific variables.  
   Terraform  
   gcp\_project\_id \= "your-gcp-project-id"  
   image\_path     \= "us-central1-docker.pkg.dev/your-gcp-project-id/defectdojo-repo"

2. **Initialize Terraform:**  
   Bash  
   terraform init

3. **Plan and Apply:**  
   Bash  
   terraform plan \-out=tfplan  
   terraform apply "tfplan"

   Type yes when prompted to confirm. The deployment will take several minutes.

---

### **Step 6: Run the Initializer Job**

After Terraform finishes, the infrastructure is ready, but the database is empty. You must run the initializer job to set up the database schema and the admin user.

Bash

gcloud run jobs execute initializer \--region=us-central1 \--wait

The \--wait flag will cause the command to run until the job completes.  
---

### **Step 7: Access Your Application**

Your DefectDojo instance is now running\!

1. **Find the URL:** Get the URL of your uwsgi service with this command:  
   Bash  
   gcloud run services describe uwsgi \--region=us-central1 \--format="value(uri)"

2. **Log In:** Open the URL in your browser. The default credentials after running the initializer are:  
   * **Username:** admin  
   * **Password:** You will be prompted to set a new password on your first login.

You have successfully deployed a scalable DefectDojo instance on Google Cloud Run\!